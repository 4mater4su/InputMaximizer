
//
//  GeneratorView.swift
//  InputMaximizer
//
//  Created by Robin Geske on 27.08.25.
//

import SwiftUI

struct GeneratorView: View {
    @EnvironmentObject private var lessonStore: LessonStore
    @Environment(\.dismiss) private var dismiss   // optional, if you want to auto-close the screen
    
    // MARK: - State
    @State private var apiKey: String = ""
         // store/retrieve from Keychain in real use
    @State private var sentencesPerSegment = 1
    @State private var isBusy = false
    @State private var status = ""

    // Auto-filled from model output
    @State private var lessonID: String = "Lesson001"
    @State private var title: String = ""          // filled from generated PT title

    @State private var genLanguage: String = "Portugu√™s do Brasil"
    @State private var transLanguage: String = "English"
    @State private var wordCount: Int = 180
    
    private let supportedLanguages: [String] = [
        "Afrikaans","Arabic","Armenian","Azerbaijani","Belarusian","Bosnian","Bulgarian","Catalan","Chinese","Croatian",
        "Czech","Danish","Dutch","English","Estonian","Finnish","French","Galician","German","Greek","Hebrew","Hindi",
        "Hungarian","Icelandic","Indonesian","Italian","Japanese","Kannada","Kazakh","Korean","Latvian","Lithuanian",
        "Macedonian","Malay","Marathi","Maori","Nepali","Norwegian","Persian","Polish","Portuguese","Romanian","Russian",
        "Serbian","Slovak","Slovenian","Spanish","Swahili","Swedish","Tagalog","Tamil","Thai","Turkish","Ukrainian",
        "Urdu","Vietnamese","Welsh"
    ]
    
    // Modes
    enum GenerationMode: String, CaseIterable, Identifiable {
        case random = "Random"
        case prompt = "Prompt"
        var id: String { rawValue }
    }
    @State private var mode: GenerationMode = .random
    @State private var userPrompt: String = ""

    // MARK: - Random topic source
    private let interests: [String] = [
        // üå± Movement / Embodied Practices
        "capoeira rodas ao amanhecer",
        "princ√≠pios e filosofia do jiu-j√≠tsu",
        "kuzushi (desequilibrar) aplicado ao cotidiano",
        "respira√ß√£o sob estresse (breathwork)",
        "rituais do surf e leitura do swell",
        "treino de apneia e mergulho livre",
        "taiji ao amanhecer em neblina de montanha",
        "peregrina√ß√µes a p√© e seus rituais",
        "dan√ßa improvisada como narrativa corporal",
        "movimento animal inspirado no ido portal",
        "caminhar descal√ßo em terras desconhecidas",
        "jogos de equil√≠brio em pontes naturais",
        "parkour como medita√ß√£o urbana",
        "cartografar o corpo em quedas e rolamentos",
        "dan√ßa trance em desertos ao luar",
        "apneia em cavernas submersas",
        "treinos com pesos n√£o convencionais (pedras, troncos)",
        "formas elementares inspiradas no dobrar da √°gua, fogo, ar e terra",
        "movimento em espiral como fluxo de ar",
        "meditar em equil√≠brio sobre troncos flutuantes",
        "pr√°tica de ‚Äòcloud hands‚Äô em picos nevados",
        "dan√ßar ao redor de fogueiras como invoca√ß√£o",
        "explorar o ‚Äòimproviso marcial‚Äô ‚Äî luta como di√°logo criativo",
        "imitar o voo de p√°ssaros em exerc√≠cios de salto",
        "navegar movimentos de multid√£o como se fosse √°gua",

        // üåå Navigation / Orientation
        "songlines como mapas vivos da paisagem",
        "constela√ß√µes de canoa como cartas do c√©u",
        "orienta√ß√£o fluvial tradicional",
        "di√°rios de viagem costeira por vilas de pesca",
        "rotas de estrelas no deserto",
        "hutongs e os guardi√µes do tempo dos becos",
        "ecos da Rota da Seda em viagens atuais",
        "hist√≥rias de tratados marcadas na terra",
        "ler ventos em bandeiras, roupas, √°rvores",
        "topografias inventadas em sonhos l√∫cidos",
        "mapear mem√≥rias em ruas de cidades estrangeiras",
        "cartas astrais como mapas de viagem interior",
        "trilhas de c√£es de rua como orienta√ß√£o urbana",
        "navegar pelo sil√™ncio em cidades superlotadas",
        "ler dire√ß√µes no fluxo de nuvens e ventos",
        "mapear desertos como mares s√≥lidos",
        "escutar o som de √°rvores para saber caminhos",
        "usar c√¢nticos como b√∫ssola comunit√°ria",
        "c√≥digos secretos de viajantes marcados em pedras",
        "narrativas de viagem inscritas em tatuagens",
        "mapear sonhos para decidir rotas de viagem",
        "cartas do c√©u inspiradas em dobra de ar",
        "linhas de drag√£o como mapas subterr√¢neos",

        // üêæ Ecological & Animal Kinship
        "acordos com esp√≠ritos do rio no folclore",
        "trocas de corv√≠deos (gralhas/corvos) com pessoas",
        "hier√≥glifos das baleias e migra√ß√µes",
        "comunidades de c√£es de rua e sua √©tica",
        "etiqueta com tubar√µes em tradi√ß√µes locais",
        "migra√ß√£o de renas na Lap√¥nia",
        "rede micorr√≠zica como 'correio' subterr√¢neo",
        "floresc√™ncias bioluminescentes no mar",
        "contos da aurora narrados por anci√£os",
        "amizades interestelares com c√£es de rua",
        "escuta de cogumelos psicod√©licos em florestas",
        "mitologias do lobo no c√≠rculo √°rtico",
        "espelhos l√≠quidos de lagos boreais",
        "intelig√™ncia das algas bioluminescentes",
        "correspond√™ncia entre abelhas e poetas",
        "esp√≠rito-guardi√£o em forma de c√£o",
        "mito da rena como guia de viajante",
        "companheirismo com esp√≠ritos-animais (daemons, totens)",
        "o c√£o como guia n√¥made e companheiro espiritual",
        "vozes dos b√∫falos-d‚Äô√°gua em mitos orientais",
        "dan√ßas de baleias como gram√°tica c√≥smica",
        "cavalos mong√≥is como parceiros de viagem",
        "mimetizar gestos de lobos no gelo",
        "esp√≠ritos de corujas como guardi√µes noturnos",
        "c√≥digos secretos de formigueiros em florestas",
        "navegar pelo canto de aves migrat√≥rias",
        "contato vision√°rio com animais de poder em rituais",

        // üèÆ Cultural Practices & Histories
        "capoeira como resist√™ncia e arte comunit√°ria",
        "bibliotecas de favela como √¢ncoras culturais",
        "hist√≥rias orais dos barcos-correio fluviais",
        "ermit√µes de Wudang nas montanhas",
        "estrada do ch√° e do cavalo (tea-horse road)",
        "rituais da jade e seus simbolismos",
        "duelos ao crep√∫sculo na mem√≥ria popular",
        "poesia antes do combate (ritual e foco)",
        "cerim√¥nias de retomada de terra (land-back)",
        "cerim√¥nias do ch√° psicod√©lico em florestas",
        "lendas de guardi√µes de passagens de montanha",
        "hist√≥rias orais de monges andarilhos",
        "rituais de enterrar objetos em viagens",
        "bibliotecas vivas (pessoas como livros)",
        "mem√≥rias tatuadas em marinheiros",
        "culturas de sauna como ritos de purifica√ß√£o",
        "mitos n√≥rdicos reinventados em viagens ao norte",
        "rituais elementares em vilarejos de montanha",
        "lendas sobre dobradores esquecidos do vento",
        "hist√≥rias de n√¥mades do fogo no deserto",
        "tradi√ß√µes de mergulhadores japoneses (ama) como dobradores de √°gua",
        "rituais xam√¢nicos do √Årtico",
        "arquitetura que dobra vento e sombra",
        "cultos √† aurora como renascimento espiritual",
        "hist√≥rias dos far√≥is como dobradores de luz",
        "narrativas sobre os primeiros mapas mundiais",
        "contos de povos que viajavam apenas pelo som",

        // üìì Observational / Field Notes
        "notas de campo em cavernas de permafrost",
        "roteiros de expedi√ß√£o para ver a aurora",
        "marginalia em manuscritos antigos",
        "rolos de receitas de cozinhas costeiras",
        "registros de bordo durante mar√©s de tempestade",
        "a voz de um cinto gasto de jiu-j√≠tsu (objeto-narrador)",
        "boletins de auditorias do cofre de sementes",
        "hist√≥rias orais dos anos de seca",
        "perfil de um guardi√£o de mar√©grafo",
        "di√°rios de sonhos como guias de viagem",
        "cartas a um daemon imagin√°rio",
        "croquis de mochileiro em abrigos improvisados",
        "notas sobre di√°logos com estranhos em trens noturnos",
        "mapas desenhados na areia antes da mar√© subir",
        "registros sobre luzes do norte como or√°culos",
        "descri√ß√µes de sinestesias induzidas por cogumelos",
        "cr√¥nicas de c√£es-guia invis√≠veis em viagens",
        "cadernos de campo sobre movimentos elementares",
        "esbo√ßos de aurora como s√≠mbolos arquet√≠picos",
        "mapas de vento rabiscados em di√°rios de viagem",
        "fragmentos de mitos recolhidos em feiras e mercados",
        "ilustra√ß√µes de constela√ß√µes inventadas",
        "hist√≥rias recolhidas em banhos p√∫blicos tradicionais",

        // üåÄ Philosophical / Mind Axis
        "instantes de wu wei na vida di√°ria",
        "despir identidades em peregrina√ß√µes",
        "fenomenologia na chuva (perceber e descrever)",
        "o Navio de Teseu em decis√µes pessoais",
        "azar moral e escolhas pequenas",
        "o ritual da paz merecida ap√≥s conflito",
        "paradoxos como trilhas de pensamento",
        "meditar sobre o vazio em florestas boreais",
        "identidade dissolvida em festivais n√¥mades",
        "eterno retorno como b√∫ssola interior",
        "psicod√©licos como mestres filos√≥ficos",
        "wu wei aplicado ao nomadismo digital",
        "a sombra junguiana em viagens solit√°rias",
        "arqueologia da imagina√ß√£o",
        "a dobra do ar como met√°fora para wu wei",
        "psicod√©licos como portais para elementos internos",
        "a leveza do ser como dobra do vento",
        "ra√≠zes como s√≠mbolo de perman√™ncia (dobra da terra)",
        "chamas internas como desejo e transforma√ß√£o",
        "a √°gua como mem√≥ria e esquecimento",
        "meditar em paradoxos como exerc√≠cio de dobra",
        "daemons como reflexos da alma junguiana",
        "trilhas n√¥mades como met√°foras de identidade fluida",
        "unir corpo e mente como dobrar os cinco elementos ocultos",

        // ‚ú® Bonus: Practice + Place blends
        "princ√≠pios de alavanca do jiu-j√≠tsu aplicados a negocia√ß√µes",
        "mapear um bairro caminhando em sil√™ncio",
        "aprender correntes e ventos com pescadores",
        "cadernos de campo sobre pontes e travessias",
        "cultura de feira livre e seus sinais",
        "rituais do ch√° como cron√¥metro social",
        "museus ao ar livre em costas rochosas",
        "hist√≥rias de far√≥is e seus guardi√µes",
        "aprendizados de navega√ß√£o com estrelas em praias urbanas",
        "aprender linguagens locais atrav√©s de can√ß√µes de feira",
        "rituais com c√£es de rua em portos estrangeiros",
        "poesia improvisada em caf√©s de esquina",
        "andarilho psicod√©lico em Lap√¥nia",
        "c√≥digos de movimento lidos em escadas de metr√¥",
        "banhos de rio como medita√ß√£o coletiva",
        "navegar cidades pelo cheiro de especiarias",
        "cerim√¥nias do p√¥r do sol em praias desconhecidas",
        "meditar em fontes termais como dobra da √°gua e fogo",
        "aprendendo idiomas com viajantes ao redor da fogueira",
        "caminhar em sil√™ncio em florestas boreais",
        "dan√ßar sob auroras como ritual de viagem",
        "tecer mapas de vento em praias urbanas",
        "cerim√¥nias de ch√° psicod√©lico na Lap√¥nia",
        "conversar com anci√£os do norte sobre mitos de gelo",
        "rituais elementares recriados em desertos",
        "di√°rios de viagem em cidades que lembram a Ba Sing Se"
    ]

    // MARK: - UI
    var body: some View {
        Form {
            Section("OpenAI") {
                SecureField("API Key", text: $apiKey)
                    .textInputAutocapitalization(.never)
                    .disableAutocorrection(true)
            }

            Section("Mode") {
                Picker("Generation Mode", selection: $mode) {
                    ForEach(GenerationMode.allCases) { m in
                        Text(m.rawValue).tag(m)
                    }
                }
                .pickerStyle(.segmented)
            }

            if mode == .prompt {
                Section("Prompt") {
                    TextEditor(text: $userPrompt)
                        .frame(minHeight: 120)
                        .overlay(RoundedRectangle(cornerRadius: 8).stroke(Color.secondary.opacity(0.2)))
                        .padding(.vertical, 2)
                    Text("Describe instructions, a theme, or paste a source text.")
                        .font(.footnote).foregroundStyle(.secondary)
                }
            }

            Section("Options") {
                Stepper("Sentences per segment: \(sentencesPerSegment)", value: $sentencesPerSegment, in: 1...3)

                Stepper("Approx. words: \(wordCount)", value: $wordCount, in: 50...1000, step: 50)

                Picker("Generate in", selection: $genLanguage) {
                    ForEach(supportedLanguages, id: \.self) { Text($0).tag($0) }
                }
                .pickerStyle(.menu)

                Picker("Translate to", selection: $transLanguage) {
                    ForEach(supportedLanguages, id: \.self) { Text($0).tag($0) }
                }
                .pickerStyle(.menu)
            }

            Section {
                Button {
                    Task { await generate() }
                } label: {
                    HStack {
                        if isBusy { ProgressView() }
                        Text(isBusy ? "Generating..." : "Generate Lesson")
                    }
                }
                .disabled(apiKey.isEmpty || isBusy || (mode == .prompt && userPrompt.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines).isEmpty))
                if !status.isEmpty { Text(status).font(.footnote).foregroundStyle(.secondary) }
            }
        }
        .navigationTitle("Generator")
    }

    // MARK: - Models
    struct Seg: Codable { let id:Int; let pt_text:String; let en_text:String; let pt_file:String; let en_file:String }
    struct LessonEntry: Codable, Identifiable, Hashable { let id:String; let title:String; let folderName:String }

    // MARK: - Utils
    func slugify(_ input: String) -> String {
        // remove diacritics, keep alphanumerics, dash, underscore; replace spaces with underscores
        var s = input.folding(options: .diacriticInsensitive, locale: .current)
        s = s.replacingOccurrences(of: " ", with: "_")
        let allowed = CharacterSet.alphanumerics.union(CharacterSet(charactersIn: "-_"))
        s = String(s.unicodeScalars.filter { allowed.contains($0) })
        if s.isEmpty { s = "Lesson_" + String(Int(Date().timeIntervalSince1970)) }
        return s
    }

    func save(_ data: Data, to url: URL) throws {
        try FileManager.default.createDirectory(at: url.deletingLastPathComponent(), withIntermediateDirectories: true)
        try data.write(to: url, options: .atomic)
    }

    // MARK: - LLM prompts
    func generateText(topic: String, targetLang: String, wordCount: Int) async throws -> String {
        let prompt = """
        Write a short, clear, factual text (~\(wordCount) words) in \(targetLang) about: \(topic).

        Rules:
        1) First line: TITLE only (no quotes).
        2) Blank line.
        3) Body in short sentences.
        4) Include exactly one plausible numeric detail in the body.
        """
        let body: [String:Any] = [
            "model": "gpt-4o-mini",
            "messages": [
                ["role":"system","content":"Be clear, concrete, and factual."],
                ["role":"user","content": prompt]
            ],
            "temperature": 0.7
        ]
        return try await chat(body: body)
    }

    func generateText(fromPrompt promptText: String, targetLang: String, wordCount: Int) async throws -> String {
        let prompt = """
        The user will provide instructions, a theme, or even a source text. Write a short, clear, factual text (~\(wordCount) words) in \(targetLang).

        Rules:
        1) First line: TITLE only (no quotes).
        2) Blank line.
        3) Body in short sentences.
        4) Include exactly one plausible numeric detail in the body.

        User input:
        \(promptText)
        """
        let body: [String:Any] = [
            "model": "gpt-4o-mini",
            "messages": [
                ["role":"system","content":"Follow the user's input. Be clear, concrete, and factual."],
                ["role":"user","content": prompt]
            ],
            "temperature": 0.7
        ]
        return try await chat(body: body)
    }


    func translate(_ text: String, to targetLang: String) async throws -> String {
        let body: [String:Any] = [
            "model":"gpt-5-nano",
            "messages":[
                ["role":"system","content":"Translate naturally and idiomatically."],
                ["role":"user","content":"Translate into \(targetLang):\n\n\(text)"]
            ],
            "temperature": 1.0
        ]
        return try await chat(body: body)
    }

    func chat(body: [String:Any]) async throws -> String {
        let url = URL(string: "https://api.openai.com/v1/chat/completions")!
        var req = URLRequest(url: url)
        req.httpMethod = "POST"
        req.addValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        req.addValue("application/json", forHTTPHeaderField: "Content-Type")
        req.httpBody = try JSONSerialization.data(withJSONObject: body)
        let (data, _) = try await URLSession.shared.data(for: req)
        let j = try JSONSerialization.jsonObject(with: data) as! [String:Any]
        let content = (((j["choices"] as? [[String:Any]])?.first?["message"] as? [String:Any])?["content"] as? String) ?? ""
        return content.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)
    }

    func tts(_ text:String, filename:String, folder:URL) async throws -> URL {
        let url = URL(string: "https://api.openai.com/v1/audio/speech")!
        var req = URLRequest(url: url)
        req.httpMethod = "POST"
        req.addValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        req.addValue("application/json", forHTTPHeaderField: "Content-Type")
        let body: [String:Any] = [
            "model": "gpt-4o-mini-tts",
            "voice": "shimmer",
            "input": text,
            "format": "mp3"
        ]
        req.httpBody = try JSONSerialization.data(withJSONObject: body)
        let (data, _) = try await URLSession.shared.data(for: req)
        let out = folder.appendingPathComponent(filename)
        try save(data, to: out)
        return out
    }

    func languageSlug(_ name: String) -> String {
        let s = slugify(name).lowercased()
        // keep it short but unique-ish
        return String(s.prefix(6))   // e.g., "portug", "englis", "deutsc"
    }
    
    // MARK: - Generate
    func generate() async {
        isBusy = true
        defer { isBusy = false }

        do {
            // 1) Build text (title + body) depending on mode
            let fullText: String
            switch mode {
            case .random:
                let topic = interests.randomElement() ?? "capoeira rodas ao amanhecer"
                status = "Generating‚Ä¶ (Random)\nTopic: \(topic)\nLang: \(genLanguage) ‚Ä¢ ~\(wordCount) words"
                fullText = try await generateText(topic: topic, targetLang: genLanguage, wordCount: wordCount)
            case .prompt:
                let cleaned = userPrompt.trimmingCharacters(in: .whitespacesAndNewlines)
                guard !cleaned.isEmpty else { status = "Please enter a prompt."; return }
                status = "Generating‚Ä¶ (Prompt)\nLang: \(genLanguage) ‚Ä¢ ~\(wordCount) words"
                fullText = try await generateText(fromPrompt: cleaned, targetLang: genLanguage, wordCount: wordCount)
            }


            // 2) Parse title + body from the model output
            // Parse title + body from the model output
            let lines = fullText.split(separator: "\n", omittingEmptySubsequences: false)
            let generatedTitle = lines.first.map(String.init)?
                .trimmingCharacters(in: .whitespacesAndNewlines)
                ?? "Sem T√≠tulo"
            let bodyPrimary = lines.dropFirst().joined(separator: "\n")
                .trimmingCharacters(in: .whitespacesAndNewlines)

            self.title = generatedTitle
            var folder = slugify(generatedTitle)

            let baseRoot = FileManager.docsLessonsDir
            var base = baseRoot.appendingPathComponent(folder, isDirectory: true)
            if (try? base.checkResourceIsReachable()) == true {
                folder += "_" + String(Int(Date().timeIntervalSince1970))
                base = baseRoot.appendingPathComponent(folder, isDirectory: true)
            }
            self.lessonID = folder

            status = "Translating to \(transLanguage)‚Ä¶\nT√≠tulo: \(generatedTitle)"

            // Avoid translating into the same language
            let secondaryText: String
            if genLanguage.lowercased().trimmingCharacters(in: .whitespacesAndNewlines)
                == transLanguage.lowercased().trimmingCharacters(in: .whitespacesAndNewlines) {
                secondaryText = bodyPrimary
            } else {
                secondaryText = try await translate(bodyPrimary, to: transLanguage)
            }

            // 5) Segment: chunk into groups of N sentences
            func sentences(_ txt: String) -> [String] {
                txt.split(whereSeparator: { ".!?".contains($0) })
                    .map { $0.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines) }
                    .filter { !$0.isEmpty }
                    .map { s in
                        if s.hasSuffix(".") || s.hasSuffix("!") || s.hasSuffix("?") { return s }
                        return s + "."
                    }
            }
            func chunk<T>(_ array: [T], size: Int) -> [[T]] {
                guard size > 0 else { return [] }
                return stride(from: 0, to: array.count, by: size).map { i in
                    Array(array[i..<min(i + size, array.count)])
                }
            }

            let sentPrimary = sentences(bodyPrimary)
            let sentSecondary = sentences(secondaryText)

            let segsPrimary: [String] = chunk(sentPrimary, size: sentencesPerSegment).map { $0.joined(separator: " ") }
            let segsSecondary: [String] = chunk(sentSecondary, size: sentencesPerSegment).map { $0.joined(separator: " ") }

            let count = min(segsPrimary.count, segsSecondary.count)
            let ptSegs = Array(segsPrimary.prefix(count))
            let enSegs = Array(segsSecondary.prefix(count))

            status = "Preparing audio‚Ä¶ \(count) segments √ó \(sentencesPerSegment) sentences"

            // 6) Create folder and TTS
            try FileManager.default.createDirectory(at: base, withIntermediateDirectories: true)

            var rows: [Seg] = []
            
            let src = languageSlug(genLanguage)
            let dst = languageSlug(transLanguage)

            for i in 0..<count {
                status = "TTS \(i+1)/\(count) \(genLanguage)‚Ä¶"
                let ptFile = "\(src)_\(lessonID)_\(i+1).mp3"
                _ = try await tts(ptSegs[i], filename: ptFile, folder: base)

                status = "TTS \(i+1)/\(count) \(transLanguage)‚Ä¶"
                let enFile = "\(dst)_\(lessonID)_\(i+1).mp3"
                _ = try await tts(enSegs[i], filename: enFile, folder: base)

                rows.append(.init(id: i+1, pt_text: ptSegs[i], en_text: enSegs[i], pt_file: ptFile, en_file: enFile))
            }

            // 7) segments_<lesson>.json
            let segJSON = base.appendingPathComponent("segments_\(lessonID).json")
            let segData = try JSONEncoder().encode(rows)
            try save(segData, to: segJSON)

            // 8) update lessons.json in Documents
            struct Manifest: Codable { var id:String; var title:String; var folderName:String }
            let manifestURL = FileManager.docsLessonsDir.appendingPathComponent("lessons.json")
            var list: [Manifest] = []
            if let d = try? Data(contentsOf: manifestURL) {
                list = (try? JSONDecoder().decode([Manifest].self, from: d)) ?? []
                list.removeAll { $0.id == lessonID }
            }
            list.append(.init(id: lessonID, title: title, folderName: lessonID))
            let out = try JSONEncoder().encode(list)
            try save(out, to: manifestURL)
            
            await MainActor.run {
                lessonStore.load()    // refresh the list without restarting
                // dismiss()          // <- uncomment if you want to auto-close Generator after success
            }

            status = "Done. Open the lesson list and pull to refresh."
        } catch {
            status = "Error: \(error.localizedDescription)"
        }
    }

}
